'''

Created on Thrus 03 Mar 2022
Author: Melisa

This script uses information that was generated by tracking_vector
which creates n_trials files for each session with the nose, ear1, ear2, head  and body positions.

Also this script will use the information from the timeline files created when analysing calcium videos
and the calcium traces to check on length of individual parts.

It needs also the information of the object locations from excels file

Will generate a discrete vector with information about the moments when the animal is involved in certain ethogram
defined behaviours.

1. Navigation : animal is far away from the object (circle defined as 200px radious) and running at speed > 2cm/s
2. Resting    : animal is far away from the object circle defined as 200px radious and speed < 2cm/s
3. Exploring  : animal is close to object (with a big radius of 200px) and is inspecting it, or it is at a closer distance (radius < 100 px)
4. Inspection : animal is looking at the object (angle between head direction and object direcction < 45')

Exploting and inspection can be divided in the different objects the animal is looking at, given by the positions of the objects.

1. LL : lower left object
2. LR : Lower right object
3. UL : uper left object
4. UR : uper right object

'''

import os
import src.Alonso.configuration
import pandas as pd
import numpy as np
import pickle
import math
import src.behavioural_analysis_functions as beh_func
from scipy.ndimage import gaussian_filter
import scipy.io as sciio

## select mouse and session to analyze
mouse = 411857
session = 1
MIN_EXPLORATION = 1 # frames taking into account videos are already in 10fps
MIN_LOOKING = 1   # frames taking into account videos are already in 10fps

RADIUS1 = 200 # in pixels, big circle
RADIUS2 = 150  # in pixels, inner circle
SPEED_LIM = 5   # speed in pixels

## object positions directory
for session in [1,2,3]:
    current_directory  = os.environ['DATA_DIR_LOCAL'] +f'{mouse}'+'/'

    ## source extracted calcium traces directory
    calcium_directory = os.environ['DATA_DIR_LOCAL'] +f'{mouse}'+'/' + 'data/calcium_activity_day_wise/'
    ## timeline directory
    timeline_file_dir =os.environ['DATA_DIR_LOCAL'] +f'{mouse}'+'/' + 'data/timeline/'

    objects_file_name = current_directory + 'training_sheet_411857.xlsx'
    objects_list_structure = ['condition', 'goal','group','session','drug','subject', 'trial','day', 'loc_1','loc_2']

    object_list = pd.read_excel(objects_file_name)
    object_list = pd.DataFrame(object_list,columns=objects_list_structure)

    #current_object_data = object_list[ object_list.subject == mouse]
    current_object_data =object_list[object_list.session == session]
    objects = ['LR', 'LL', 'UR', 'UL']

    ## behaviour directory
    behaviour_path = os.environ['PROJECT_DIR_LOCAL'] + 'data/compiled_positions/'+f'{mouse}'+'/week'+ f'{session}'+'/'
    ## output directoy
    category_path = os.environ['PROJECT_DIR_LOCAL']  + 'data/ethogram/'+f'{mouse}'+'/week'+ f'{session}'+'/'


    timeline_length=[10,10,10,10,2]
    session_trial = []
    session_trial.append(np.arange(1,6))
    session_trial.append(np.arange(6,11))
    session_trial.append(np.arange(11,16))
    session_trial.append(np.arange(16,21))
    session_trial.append(np.arange(21,22))

    day = 0
    for trial_day in [1,6,11,16]:
        print(day)
        ## load calcium activity
        file_name = 'mouse_'+f'{mouse}'+'_session_'+f'{session}'+'_trial_'+f'{trial_day}' +'_v1.4.20.3.0.1.1.0.npy'
        activity = np.load(calcium_directory + file_name)

        ## load timeline
        timeline_file_path = timeline_file_dir + 'mouse_' + f'{mouse}' + '_session_' + f'{session}' + '_trial_1_v' + f'{1}' + '.4.' + f'{1}' + \
                              '.' + f'{0}' + '_10.pkl'
        timeline_file= open(timeline_file_path,'rb')
        timeline_info = pickle.load(timeline_file)

        timeline = np.zeros(timeline_length[day]+1)
        for i in range(timeline_length[day]):
            timeline[i] = timeline_info[i][1]
        timeline[len(timeline)-1] = activity.shape[1]
        trial_duration = np.diff(timeline)

        ## create vector to save behaviour
        behaviour_vector = np.zeros((activity.shape[1],1))
        inspection_vector = np.zeros((activity.shape[1],1))
        ethogram_vector = np.zeros((activity.shape[1],1))
        ethogram_vector_ID = np.zeros((activity.shape[1],1))
        speed_vector = np.zeros((activity.shape[1],1))

        ## load tracking of behaviour
        for trial in range(len(session_trial[day])):

            # load objects positions for this trial
            object1 = current_object_data.iloc[trial]['loc_1']
            object2 = current_object_data.iloc[trial]['loc_2']
            ## define coordinates of objects in pixels acording to the frame size
            ## and define the exploratory flag

            if object1 == 'LL':
                object1_x = 800
                object1_y = 250
                exploratory_flag1 = 3
                looking_flag1 = 7
            if object1 == 'LR':
                object1_x = 300
                object1_y = 250
                exploratory_flag1 = 4
                looking_flag1 = 8
            if object1 == 'UR':
                object1_x = 300
                object1_y = 700
                exploratory_flag1 = 5
                looking_flag1 = 9
            if object1 == 'UL':
                object1_x = 800
                object1_y = 700
                exploratory_flag1 = 6
                looking_flag1 = 10

            if object2 == 'LL':
                object2_x = 800
                object2_y = 250
                exploratory_flag2 = 3
                looking_flag2 = 7
            if object2 == 'LR':
                object2_x = 300
                object2_y = 250
                exploratory_flag2 = 4
                looking_flag2 = 8
            if object2 == 'UR':
                object2_x = 300
                object2_y = 700
                exploratory_flag2 = 5
                looking_flag2 = 9
            if object2 == 'UL':
                object2_x = 800
                object2_y = 700
                exploratory_flag2 = 6
                looking_flag2 = 10

            coordinates1 = np.array([object1_x, object1_y])
            coordinates2 = np.array([object2_x, object2_y])

            beh_file_name = 'mouse_' + f'{mouse}' + '_session_' + f'{session}' + '_trial_' + \
                            f'{session_trial[day][trial]}' + '_likelihood_0.75.npy'
            beh_path = behaviour_path + beh_file_name
            if not os.path.isfile(beh_path):
                print('ERROR: Behaviour file not found:' + beh_path)
            else:
                tracking = np.load(beh_path)

                init_trial = int(timeline[trial * 2])
                end_trial = int(timeline[trial * 2 + 1])
                duration = np.min((tracking.shape[0], end_trial - init_trial))

                x_positions_pre_nose = tracking[:, 0].T
                y_positions_pre_nose = tracking[:, 1].T
                x_positions_inter_nose, y_positions_inter_nose = beh_func.interpolate_positions(x_positions_pre_nose,
                                                                                                y_positions_pre_nose)
                x_positions_nose = x_positions_inter_nose  # gaussian_filter(x_positions_inter_nose, sigma=2)
                y_positions_nose = y_positions_inter_nose  # gaussian_filter(y_positions_inter_nose, sigma=2)

                x_positions_pre_head = tracking[:, 2].T
                y_positions_pre_head = tracking[:, 3].T
                x_positions_inter_head, y_positions_inter_head = beh_func.interpolate_positions(x_positions_pre_head,
                                                                                                    y_positions_pre_head)
                x_positions_head = x_positions_inter_head  # gaussian_filter(x_positions_inter_head, sigma=2)
                y_positions_head = y_positions_inter_head  # gaussian_filter(y_positions_inter_head, sigma=2)

                position = np.array([x_positions_head, y_positions_head]).T
                position_nose = np.array([x_positions_nose, y_positions_nose]).T
                vx = np.zeros((x_positions_head.shape[0], 1))
                vy = np.zeros((y_positions_head.shape[0], 1))
                vx[1:, 0] = np.diff(position[:, 0])
                vy[1:, 0] = np.diff(position[:, 1])
                speed = np.sqrt(vx * vx + vy * vy)

                ## get points coordinates for head direction and objects location
                p2 = position_nose  # nose position
                p1 = position  # head position
                p3 = coordinates1 * np.ones_like(p1)
                p4 = coordinates2 * np.ones_like(p1)

                ## binary looking at object vectors
                looking_vector1, angle1_vector = beh_func.looking_at_vector(p2, p1, p3)
                looking_vector2, angle2_vector = beh_func.looking_at_vector(p2, p1, p4)

                ## proximity vector between mouse position and objects
                proximity_vector1 = beh_func.proximity_vector(position, p3, radius=RADIUS1)
                proximity_vector2 = beh_func.proximity_vector(position, p4, radius=RADIUS1)

                ## super proximity vector for mouse position and objects (closer that proximity1)
                super_proximity_vector1 = beh_func.proximity_vector(position, p3, radius=RADIUS2)
                super_proximity_vector2 = beh_func.proximity_vector(position, p4, radius=RADIUS2)

                ## select events of a certain duration
                looking_vector1_last = beh_func.long_duration_events(looking_vector1, MIN_LOOKING)
                looking_vector2_last = beh_func.long_duration_events(looking_vector2, MIN_LOOKING)

                proximity_vector1_last = beh_func.long_duration_events(proximity_vector1, MIN_EXPLORATION)
                proximity_vector2_last = beh_func.long_duration_events(proximity_vector2, MIN_EXPLORATION)

                super_proximity_vector1_last = beh_func.long_duration_events(super_proximity_vector1, MIN_EXPLORATION)
                super_proximity_vector2_last = beh_func.long_duration_events(super_proximity_vector2, MIN_EXPLORATION)

                ## now check for all data points
                for i in range(position.shape[0]):
                    speed_vector[init_trial + i] = speed[i]
                    if position[i, 0] > 0 and position[i, 1] > 0:
                        closeness = 0
                        inspection = 0
                        if proximity_vector1_last[i] and not math.isnan(angle1_vector[i]):
                            if looking_vector1_last[i] or super_proximity_vector1_last[i]:
                                ethogram_vector[init_trial + i] = exploratory_flag1
                                closeness = 1
                        else:
                            if proximity_vector2_last[i] and not math.isnan(angle2_vector[i]):
                                if looking_vector2_last[i] or super_proximity_vector1[i]:
                                    ethogram_vector[init_trial + i] = exploratory_flag2
                                    closeness = 1
                        if speed[i] > SPEED_LIM and closeness == 0:
                            if looking_vector1_last[i] and not looking_vector2_last[i]:
                                    ethogram_vector[init_trial + i] = looking_flag1
                                    inspection = 1
                            if looking_vector2_last[i] and not looking_vector1_last[i]:
                                    ethogram_vector[init_trial + i] = looking_flag2
                                    inspection = 1
                            if inspection == 0:
                                ethogram_vector[init_trial + i] = 2
                        if speed[i] <= SPEED_LIM and closeness == 0 and inspection == 0:
                                ethogram_vector[init_trial + i] = 1

        output_tracking_file = 'mouse_' + f'{mouse}' + '_session_' + f'{session}' + '_day_' + \
                               f'{day + 1}' + '_likelihood_0.75_ethogram.npy'
        output_tracking_path = category_path + output_tracking_file
        sciio.savemat(category_path + 'mouse_' + f'{mouse}' + '_session_' + f'{session}' + '_day_' + \
                          f'{day + 1}' + '_likelihood_0.75_ethogram.mat', {'ethogram': ethogram_vector})
        np.save(output_tracking_path,ethogram_vector)
        day = day+1


import matplotlib.pyplot as plt
plt.plot(position_nose[np.where(proximity_vector1)[0],0],position_nose[np.where(proximity_vector1)[0],1])
plt.plot(position_nose[np.where(proximity_vector2)[0],0],position_nose[np.where(proximity_vector2)[0],1])
plt.xlim([0,1000])
plt.ylim([0,1000])
plt.show()

import matplotlib.pyplot as plt
plt.plot(position_nose[np.where(ethogram_vector == 4)[0],0],position_nose[np.where(ethogram_vector == 4)[0],1])
plt.plot(position_nose[np.where(ethogram_vector == 5)[0],0],position_nose[np.where(ethogram_vector == 5)[0],1])
plt.xlim([0,1000])
plt.ylim([0,1000])
plt.show()
